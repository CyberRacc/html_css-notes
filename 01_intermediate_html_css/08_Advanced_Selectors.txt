

These advanced selectors are useful when you can't (or don't want to) change
your HTML markup.

There are a lot of advanced selectors, so this will just be about the most useful
and common ones.

## Child and sibling combinators ##

      - the descendant combinator (space)  
    > - the child combinator
    + - the adjacent sibling combinator
    ~ - the general sibling combinator

    <main class="parent">
        <div class="child group1">
            <div class="grand-child group1"></div>
        </div>
        <div class="child group2">
            <div class="grand-child group2"></div>
        </div>
        <div class="child group3">
            <div class="grand-child group3"></div>
        </div>
    </main>

    To select the child and grand-child divs inside main, you could use:

        main div {
            /* Our cool CSS */
        }

    To be more specific and select ONLY the child or grand-child divs, use the > combinator.
    It only selects direct children:

        /* This rule will only select divs with a class of child */
        main > div {
            /* Our cool CSS */
        }

        /* This rule will only select divs with a class of grand-child */
        main > div > div {
            /* More cool CSS */
        }

    The child selector will select an element that is one level of indentation down.
    
    To select an element that is adjacent to our target, or on the same level of
    indentation, use the adjacent sibling combinator +.

        /* This rule will only select the div with the class child group2 */
        .group1 + div {
            /* Our cool CSS */
        }

        /* This rule will only select the div with the class child group3 */
        .group1 + div + div {
            /* More cool CSS */
        }

    Now to select all of an element's siblings and not just the first one, we can use the
    general sibling combinator ~.

        /* This rule will select all of .group1's siblings - in this case the 2nd and 3rd .child divs */
        .group1 ~ div {
            /* Our cool CSS */
        }

    Like the descendant combinator, these selectors don't have any special
    specificity rules - their specificity score will just be made up of their
    component parts.

## Pseudo-selectors ##

    # Difference between pseudo-class and pseudo-elements #

        What's a pseudo-class?

        A pseudo-class is a selector that selects elements that are in a specific state,
        e.g. they are the first element of their type, or they are being hovered over
        by the mouse pointer. They tend to act as if you had applied a class to some
        part of your document, often helping you cut down on excess classes in your
        markup, and giving you more flexible, maintainable code.

        Pseudo-classes are keywords that start with a colon. For example, :hover
        is a pseudo-class.

        Example:

            article p:first-child {
                font-size: 120%;
                font-weight: bold;
            }

               <article>
                    <p>Veggies es bonus vobis, proinde vos postulo essum magis 
                            kohlrabi welsh onion daikon amaranth tatsoi tomatillo
                            melon azuki bean garlic.</p>

                    <p>Gumbo beet greens corn soko endive gumbo gourd. Parsley 
                            shallot courgette tatsoi pea sprouts fava bean collard
                            greens dandelion okra wakame tomato. Dandelion cucumber
                            earthnut pea peanut soko zucchini.</p>
                </article>

                What if a new paragraph got added to the top of the document?
                We'd need to move the class over to the new paragraph. Instead of
                adding the class, we could use the :first-child pseudo-class selector â€”
                this will always target the first child element in the article, and we
                will no longer need to edit the HTML (this may not always be possible anyway,
                maybe due to it being generated by a CMS).

            Some other pseudo-classes:

                :last-child
                :only-child
                :invalid

            What is a pseudo-element?

            pseudo-elements behave in a similar way. However, they act as if you had added
            a whole new HTML element into the markup, rather than applying a class to
            existing elements.

            pseudo-elements start with a double colon ::. ::before is an example.

            For example, if you wanted to select the first line of a paragraph you
            could wrap it in a <span> element and use an element selector; however,
            that would fail if the number of words you had wrapped were longer or shorter
            than the parent element's width. As we tend not to know how many words will
            fit on a line â€” as that will change if the screen width or font-size changes â€”
            it is impossible to robustly do this by adding HTML.

            The ::first-line pseudo-element selector will do this for you reliably â€”
            if the number of words increases or decreases it will still only select the
            first line.

            article p::first-line {
                font-size: 120%;
                font-weight: bold;
            }   

            <article>
            <p>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion
                    daikon amaranth tatsoi tomatillo
                    melon azuki bean garlic.</p>

            <p>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette
                    tatsoi pea sprouts fava bean collardgreens dandelion okra wakame tomato.
                    Dandelion cucumber earthnut pea peanut soko zucchini.</p>
            </article>
    
            It acts as if a <span> was magically wrapped around that first formatted line,
            and updated each time the line length changed.
            

    Pseudo-class selectors are prefixed with a single colon and are a different way to
    target elements that already exist in HTML. Pseudo-elements are prefixed with two
    colons and are use to target elements that don't normally exist in the markup.

    Pseudo-classes share the same specificity as regular classes (0, 0, 1, 0),
    most can be chained together just like regular classes.

    The (0, 0, 1, 0) above is the notation for calculating specificity.
    
# Dynamic and user action pseudo-classes #

    These types of useful pseudo-classes can make your page feel much more dynamic and
    interactive.

    :focus applies to an element that is currently selected by the user either
    through selecting it with their cursor or using their keyboard.

    :hover will affect anything under the user's mouse pointer. It can be used to give
    extra oomph to buttons and links to highlight that they're interactable,
    or to trigger a drop-down menu.

    :active applies to elements that are currently being clicked, and this is especially
    useful for giving your user feedback that their action had an effect.
    This is a great one to give your buttons and other interactive elements more
    "tactile" feedback.

    Browsers always make links blue and change them to purple when clicked by default.
    You can implement your own styling for links, by using the :link and :visisted
    pseudo-classes. A simplified version of default browser styling might look
    something like this:

      /* This rule will apply to all links */
        a {
            text-decoration: underline;
        }

        /* This will apply to unvisited links */
        a:link {
            color: blue;
        }

        /* And you guessed it, this applies to all links the user has clicked on */
        a:visited {
            color: purple;
        }

# Structural pseudo-classes #

    These are a powerful way to select elements based on their position within the DOM.

    :root is a special class that represents the very top level of your document,
    it is the one element that has no parents. This is generally quivalent to the HTML
    element but there are a few subtle differences.

    :root is generally the place you will place your 'global' CSS rules that you want
    available everywhere, such as custom properties and CSS variables, or rules such as
    box-sizing: border-box;.

    :first-child and :last-child will match elements that are the first or last
    sibling.

    Similarly, :empty will match elements that have no children at all, and :only-child
    will match elements that don't have any siblings.

    For a more dynamic approach we can use :nth-child. This is a flexible pseudo-class
    with a few different uses.

        .myList:nth-child(5) {/* Selects the 5th element with class myList */}

        .myList:nth-child(3n) { /* Selects every 3rd element with class myList */}

        .myList:nth-child(3n + 3) { /* Selects every 3rd element with class myList, beginning with the 3rd */}

        .myList:nth-child(even) {/* Selects every even element with class myList */}

## Pseudo-elements ##

    These allow us to affect parts of our HTML that aren't elements at all.

    These share the same specificity as regular elements (0, 0, 0, 1).

    Pseudo-elements are pretty useful and can be used in some creative ways.

    ::marker allows you to customise the styling of you <li> elements' bullets
    or numbers.

    ::first-letter and ::first-line allow you to give special styling to the first letter
    or line of some text.

    ::selection allows you to change the highlighting when a user selects text on
    the page.

    ::before and ::after allows us to add extra elements ondo the page with CSS, instead
    of HTML. Using it to decorate text in various ways is one common use case.

    <style>
    .emojify::before {
        content: 'ðŸ˜Ž ðŸ¥¸ ðŸ¤“';
    }

    .emojify::after {
        content: 'ðŸ¤“ ðŸ¥¸ ðŸ˜Ž';
    }
    </style>

    <body>
        <div> Let's <span class="emojify">emojify</span>this span!</div>
    </body>

    Using these pseudo-elements this way would give us this result:

    Letâ€™s ðŸ˜Ž ðŸ¥¸ ðŸ¤“ emojify ðŸ¤“ ðŸ¥¸ ðŸ˜Ž this span!

Complete list of pseudo-elements:

    https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements

## Attribute selectors ##

    An attribute is simply anything in the opening tag of a HTML element, such as
    src='picture.jpg' or href="some-url"

    Attribute selectors have the same specificity as classes and pseudo-classes
    (0, 0, 1, 0).

    [attribute] - This general selector will select anything where the given attribute
    exists. Its value doesn't matter.

    selector[attribute] - Optionally we can combine our attribute selectors with other
    types of selectors, such as class or element selectors.

    [attribute="value"] - To get really specific, we can use = to match a specific
    attribute with a specific value.

    [src] {
        /* This will target any element that has a src attribute. */
    }

    img[src] {
        /* This will only target img elements that have a src attribute. */
    }

    img[src="puppy.jpg"] {
        /* This will target img elements with a src attribute that is exactly "puppy.jpg" */
    }

    You can be more general when it comes to accessing these attributes.
    For example, if we're only interested in img elements where the src attribute's
    value ends in.jpg. For these cases we have some attribute selectors that allow
    us to match a part of the attribute's value. They have a similar syntax to regular
    expressions.

    
    [attribute^="value"] - ^= Will match strings from the start.
    [attribute$="value"] - $= Will match strings from the end.
    [attribute*="value"] - *= The wildcard selector will match anywhere inside the string.

    [class^='aus'] {
    /* Classes are attributes too!
        This will target any class that begins with 'aus':
        class='austria'
        class='australia'
    */
    }

    [src$='.jpg'] {
    /* This will target any src attribute that ends in '.jpg':
    src='puppy.jpg'
    src='kitten.jpg'
    */
    }

    [for*='ill'] {
    /* This will target any for attribute that has 'ill' anywhere inside it:
    for="bill"
    for="jill"
    for="silly"
    for="ill"
    */
    }

    